# 54-55

ПАРАГРАФ 54

1. **В каких случаях имеет смысл разрабатывать свои компоненты?**
   Разработка собственных компонентов имеет смысл, когда:
   - Существующие компоненты не удовлетворяют требованиям проекта.
   - Необходима специфическая функциональность, которая не реализована в стандартных компонентах.
   - Требуется улучшение производительности или оптимизация под конкретные задачи.
   - Необходимо создать переиспользуемый код для использования в нескольких проектах.

2. **Достоинства и недостатки использования своих компонентов:**
   - **Достоинства:**
     - Полный контроль над функциональностью и поведением компонента.
     - Возможность оптимизации под конкретные задачи.
     - Упрощение поддержки и модификации кода.
   - **Недостатки:**
     - Время и ресурсы на разработку и тестирование.
     - Риск ошибок и недоработок, если компонент не будет тщательно протестирован.
     - Необходимость поддерживать компонент в будущем.

3. **Почему программисты редко создают свои компоненты «с нуля»?**
   Программисты предпочитают использовать готовые компоненты, так как это экономит время и усилия. Готовые решения часто хорошо протестированы и документированы, что снижает риск ошибок. Кроме того, разработка с нуля требует глубокого понимания всех аспектов реализации.

4. **Связь классов TIntEdit и TEdit:**
   Класс TIntEdit является наследником класса TEdit. Это означает, что TIntEdit наследует все свойства и методы TEdit, но может добавлять или переопределять их для реализации специфической функциональности (например, ограничение ввода только числовыми значениями).

5. **Секции модуля для описания нового класса:**
   Описание нового класса обычно размещается в секции `interface`, а реализация методов — в секции `implementation`. Это позволяет разделить интерфейс (что класс делает) от реализации (как он это делает), что упрощает поддержку кода и его использование другими модулями.

6. **Функции для преобразования числового значения в текстовое и обратно:**
   Для преобразования числового значения в текстовое используется функция `IntToStr`, а для преобразования текстового значения в числовое — `StrToInt`.

7. **Функция для перевода числа в шестнадцатеричную систему счисления:**
   Для перевода числа в шестнадцатеричную систему используется функция `IntToHex`.

8. **Работа свойства Value у компонента TIntEdit:**
   Свойство Value у компонента TIntEdit позволяет получить или установить числовое значение, которое вводится пользователем. При установке значения происходит автоматическая проверка на корректность ввода.

9. **Обработка вводимых символов без OnKeyPress:**
   В примере может использоваться встроенная обработка ввода символов, которая уже реализована в базовом классе TEdit или через другие механизмы (например, через обработчик события OnChange), что делает дополнительный обработчик OnKeyPress излишним.

10. **Значение слова override при описании метода:**
    Слово `override` указывает на то, что метод переопределяет виртуальный метод базового класса с тем же именем и сигнатурой, позволяя изменить его поведение.

11. **Создание компонента во время выполнения программы:**
    Компонент можно создать во время выполнения программы с помощью оператора `Create`, например:
    ```pascal
    var
      MyComponent: TMyComponent;
    begin
      MyComponent := TMyComponent.Create(Self);
    end;
    ```

12. **Создание компонентов в обработчике OnCreate формы:**
    Компоненты обычно создаются в обработчике OnCreate формы для того, чтобы гарантировать их создание до начала работы с формой и ее элементами управления.

13. **Роли владельца компонента и родительского объекта:**
    Владелец компонента отвечает за его создание и уничтожение (освобождение ресурсов), тогда как родительский объект определяет визуальное размещение компонента на форме или контейнере.

14. **Установка свойств нового компонента только из программы:**
    Свойства нового компонента могут устанавливаться только из программы, если они не были объявлены как публичные или защищенные (protected) свойства, доступные через Инспектор объектов.

15. **Установка обработчика события во время выполнения программы:**
    Обработчик события можно установить во время выполнения программы следующим образом:
    ```pascal
    MyComponent.OnChange := MyChangeHandler;
    ```

16. **Использование обработчика события OnChange без объявления в классе TIntEdit:**
    Обработчик события OnChange может быть использован без явного объявления в классе TIntEdit, если он наследуется от базового класса (например, TEdit), который уже имеет это событие объявленным.
    
ПАРАГРАФ 55

1. **Чем хорошо разделение программы на модель и интерфейс? Как это связано с особенностями современного программирования?**
   Разделение программы на модель и интерфейс (например, в архитектуре MVC) позволяет:
   - Упрощать поддержку и модификацию кода, так как изменения в одной части (модели или представлении) не влияют на другую.
   - Повышать переиспользуемость кода, так как модель может быть использована с различными интерфейсами.
   - Улучшать тестируемость, так как можно тестировать модель независимо от пользовательского интерфейса.
   Это связано с современными подходами к разработке программного обеспечения, такими как Agile и DevOps, которые акцентируют внимание на гибкости, быстром реагировании на изменения и высоком качестве кода.

2. **Что обычно относят к модели, а что к представлению?**
   - **Модель**: это логика приложения и данные. Она отвечает за управление данными, бизнес-логикой и правилами. Например, в приложении для учета товаров модель может включать классы для работы с товарами, их ценами и количеством на складе.
   - **Представление**: это визуальная часть приложения, которая отвечает за отображение данных пользователю и взаимодействие с ним. Например, в том же приложении представление может включать формы для ввода данных о товарах и таблицы для их отображения.

3. **Что от чего зависит (и не зависит) в паре «модель — представление»?**
   - **Зависимости**:
     - Представление зависит от модели, так как оно отображает данные из модели.
     - Модель может зависеть от представления в том смысле, что она может иметь методы для обновления состояния или уведомления о изменениях (например, через паттерн Observer).
   - **Независимости**:
     - Модель не должна зависеть от конкретного представления; она должна быть независимой от того, как данные будут представлены пользователю.
     - Представление не должно содержать бизнес-логики или напрямую манипулировать данными; оно должно только отображать информацию из модели.

4. **Примеры задач с выделением модели и представления:**
   - **Задача 1**: Приложение для управления задачами.
     - **Модель**: Классы `Task`, `TaskManager`, которые управляют данными о задачах (название, описание, статус).
     - **Представление**: Графический интерфейс с формами для добавления/редактирования задач и списком задач.
     - Для одной модели можно создать разные представления: веб-интерфейс, мобильное приложение или консольное приложение.

   - **Задача 2**: Приложение для учета финансов.
     - **Модель**: Классы `Transaction`, `Account`, которые управляют данными о транзакциях и счетах.
     - **Представление**: Графический интерфейс с отчетами о расходах/доходах или диаграммами.
     - Можно создать разные представления для разных пользователей (например, администратор vs обычный пользователь).

5. **Алгоритм вычисления арифметического выражения без скобок:**
   Для вычисления арифметического выражения без скобок можно использовать алгоритм "сортировочной станции" (или "алгоритм шунта"):
   1. Создайте два стека: один для чисел (операндов), другой — для операторов.
   2. Пройдите по каждому символу выражения:
      - Если символ — число, добавьте его в стек чисел.
      - Если символ — оператор (+, -, *, /), сравните его приоритет с верхним оператором в стеке операторов:
        - Если текущий оператор имеет более высокий приоритет или стек операторов пустой — добавьте его в стек операторов.
        - Если текущий оператор имеет более низкий или равный приоритет — извлеките операторы из стека до тех пор, пока не встретите оператор более низкого приоритета или стек не станет пустым; затем добавьте текущий оператор в стек.
   3. После обработки всех символов извлеките все оставшиеся операторы из стека и выполните операции между числами из стека чисел.

6. **Изменение программы для обработки выражений со скобками: что нужно изменить?**
   Для обработки выражений со скобками потребуется изменить как модель, так и интерфейс:
   - **Модель**: необходимо добавить логику для обработки скобок при вычислении выражений. Это может потребовать изменения алгоритма разбора выражения (например, использование рекурсивного спуска).
   - **Интерфейс**: если пользовательский интерфейс должен позволять вводить скобки (например, текстовое поле), то он также должен быть адаптирован под новые требования. Возможно также потребуется обновить вывод результатов или сообщения об ошибках при некорректном вводе.
